# 狄克斯特拉算法学习笔记 (Dijkstra's Algorithm Learning Notes)

本项目是我学习《算法图解》(Grokking Algorithms) 时，对狄克斯特拉 (Dijkstra's) 算法的 Python 实现和思考记录。代码的目标是找出加权有向图中，从“起点”到所有其他节点的最短路径开销。

通过不断提出问题和添加注释，我基本厘清了算法的执行流程和核心思想。这个仓库不仅存放了最终的代码，也记录了我对关键逻辑的理解过程。

## 核心思想

狄克斯特拉算法是一种“贪心”算法。它的核心思想可以概括为：

1.  从起点开始，找出离它最近的节点。
2.  更新从这个“最近的节点”出发，到达它的邻居们的路径开销。如果发现了更短的路径，就更新记录。
3.  标记这个“最近的节点”为“已处理”，不再访问。
4.  重复以上过程，在剩下所有“未处理”的节点中，继续寻找离起点最近的节点，直到所有可达节点都被处理完毕。

## 四个关键的数据结构

为了实现这个算法，我设置了四个核心的数据结构，理解它们的作用是理解整个算法的关键：

1.  **图 (`graph`)**: 一个嵌套字典，用来表示整个网络。

      * **外层字典的键**：图中的节点名称（如 `'start'`）。
      * **内层字典**：描述该节点的所有邻居及其权重（距离）。例如 `graph['start']['a'] = 6` 表示从 `'start'` 到 `'a'` 的距离是 6。

2.  **开销表 (`costs`)**: 一个字典，记录了从“起点”到其他各个节点的**已知最低开销**。这个表是动态更新的，初始值可能不是最终的最短路径。对于无法直接到达的节点，初始开销为无穷大 (`infinity`)。

3.  **父节点表 (`parents`)**: 一个字典，用来“追踪”最短路径。`parents['a'] = 'b'` 意味着，在通往节点 `'a'` 的最短路径中，它的上一个节点是 `'b'`。通过这张表，我们可以从终点反向回溯，最终找到完整的路径。

4.  **已处理列表 (`processed`)**: 一个列表，用于存放所有已经被处理过的节点。确保我们不会走回头路或陷入无限循环，大大提高了效率。

## 算法流程详解

整个算法的核心是一个 `while` 循环，它的每一步都遵循着“寻找-更新-标记”的模式。

### 1\. 寻找开销最低的节点

循环的第一步是调用 `find_lowest_cost_node(costs)` 函数。

  * **我的思考与理解**：我曾困惑这个函数是如何工作的，以及 `while` 循环是如何停止的。现在的理解是：这个函数像一个“打擂台”的裁判，它会遍历所有**未被处理过**的节点，找出其中开销最低的那个作为新的“擂主”。如果所有可达的节点都处理完了，或者剩下的节点都是开销无穷大的“孤岛”，那么函数就找不到新的“擂主”，返回 `None`，从而优雅地结束 `while` 循环。

### 2\. 更新邻居节点的开销

找到当前开销最低的节点 (`node`) 后，我们就遍历它的所有邻居 (`neighbors`)。

  * **我的思考与理解**：`neighbors = graph[node]` 这行代码让我明白了嵌套字典的用法。`[node]` 是作用于最外层的 `graph`，取出了代表 `node` 节点所有邻居信息的内层字典。
  * 对于每一个邻居 `n`，我们计算一个新的开销 `new_cost` (从起点到 `node` 的开销 + 从 `node` 到 `n` 的开销)。
  * `if costs[n] > new_cost:` 是算法的精髓！它在判断：“我刚发现的这条路，是不是比记录中那条旧路更近？” 如果是，就说明我们找到了一个更优的路径。

### 3\. 更新记录并标记

如果找到了更优路径，我们就更新 `costs` 表和 `parents` 表，记下这条更短的路径和它的来源。当一个节点的所有邻居都被检查完毕后，我们将它加入 `processed` 列表，表示“这个节点已经处理完毕，它是当前最优解了”。

### 4\. 重复

`while` 循环会不断重复上述过程，直到图中所有可达的节点都被处理完毕。

## 我的注释版代码

以下是我结合自己的理解和思考，添加了注释的最终代码。

```python
# 迪克斯特拉找加权图最短路径，本次练习没有加入能查找路径的每个经过的节点，只有最短路径的值

# 1. 创建图 (Graph)
# 使用一个字典来表示整个图
graph = {}
# 添加起点和它的邻居,同时加入起点到邻居的路程
# 这里用到了嵌套字典
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

# 添加其他节点和它们的邻居和路程
graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

# 添加终点
graph["fin"] = {}

# 2. 创建开销表 (Costs Table)
# 创建一个字典来存储从起点到每个节点的开销
infinity = float("inf")  # 表示无穷大
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

# 3. 创建父节点表 (Parents Table)
# 创建一个字典来存储路径，用于回溯
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None

# 4. 创建一个列表，用于记录已经处理过的节点
processed = []

def find_lowest_cost_node(costs):
    """在未处理的节点中，找出开销最低的那个"""
    lowest_cost = float("inf")  # 这里将初始最低开销记作无穷大，确保第一个节点能成为擂主
    lowest_cost_node = None     # 找不到时返回None，用于结束while循环
    
    for node in costs:  # 遍历costs字典中所有的键（节点）
        cost = costs[node]
        # 如果当前节点的开销更低，并且它还没被处理过
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost          # 更新最低开销
            lowest_cost_node = node     # 更新最低开销的节点
            
    return lowest_cost_node

# --- 算法主逻辑 ---
node = find_lowest_cost_node(costs) # 找出第一个要处理的节点

while node is not None: # 只要还能找到未处理的、开销最低的节点，就继续循环
    cost = costs[node]
    neighbors = graph[node] # 获取当前节点的所有邻居
    
    for n in neighbors: # 遍历所有邻居 (直接遍历字典默认就是遍历键)
        # 计算经当前节点到达该邻居的新开销
        new_cost = cost + neighbors[n]
        
        # 如果新路径更近，则更新记录
        if costs[n] > new_cost:
            costs[n] = new_cost # 更新开销
            parents[n] = node   # 更新父节点
            
    processed.append(node) # 将当前节点标记为已处理
    node = find_lowest_cost_node(costs) # 寻找下一个要处理的节点

# --- 打印结果 ---
print("从起点到各节点的最低开销:")
print(costs)

print("\n通向各节点的父节点:")
print(parents)
```

## 运行与输出

直接运行此 Python 脚本即可。

**预期输出:**

```
从起点到各节点的最低开销:
{'a': 5, 'b': 2, 'fin': 6}

通向各节点的父节点:
{'a': 'b', 'b': 'start', 'fin': 'a'}
```

## 学习总结

通过这次完整的练习，我深刻体会到，将一个抽象的算法分解成具体的数据结构和逻辑步骤是多么重要。虽然现在还无法完全脱稿独立复现，但我已经清晰地掌握了狄克斯特拉算法的每一步操作的意义。下一步的目标是，尝试用不同的图来测试这个算法，并最终能够不看笔记独立地将它实现出来。
